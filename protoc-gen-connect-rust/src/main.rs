// Cargo.toml dependencies needed:
// [dependencies]
// prost = "0.12"
// prost-types = "0.12"

use prost::Message;
use prost_types::compiler::{
    CodeGeneratorRequest, CodeGeneratorResponse, code_generator_response::File,
};
use std::io::{self, Read, Write};

fn main() -> io::Result<()> {
    // Read the CodeGeneratorRequest from stdin
    let mut input = Vec::new();
    io::stdin().lock().read_to_end(&mut input)?;

    // Parse the request
    let request = CodeGeneratorRequest::decode(&input[..])
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))?;

    // Build a single mod.rs that includes everything
    let mut mod_code = String::new();
    mod_code.push_str("// Generated by protoc-gen-connect-rust\n");
    mod_code.push_str("// Do not edit manually\n\n");
    mod_code.push_str("#![allow(unused)]\n\n");

    // Process each proto file
    for file in &request.proto_file {
        // Only generate for files we're supposed to process
        let file_name = file.name.as_deref().unwrap_or("");
        if !request.file_to_generate.contains(&file_name.to_string()) {
            continue;
        }

        let package = file.package.as_deref().unwrap_or("");
        let package_parts: Vec<&str> = package.split('.').collect();

        // Generate nested module structure
        for (i, part) in package_parts.iter().enumerate() {
            let indent = "    ".repeat(i);
            mod_code.push_str(&format!("{}pub mod {} {{\n", indent, part));
        }

        let indent = "    ".repeat(package_parts.len());

        // Include the prost-generated types
        let prost_file = format!("{}.rs", package);
        mod_code.push_str(&format!("{}include!(\"{}\");\n\n", indent, prost_file));

        // Generate service traits for this file
        for service in &file.service {
            let service_name = service.name.as_deref().unwrap_or("UnknownService");

            // Generate the service trait
            mod_code.push_str(&format!(
                "{}/// Generated service trait for {}\n",
                indent, service_name
            ));
            mod_code.push_str(&format!(
                "{}pub trait {}: Send + Sync + 'static {{\n",
                indent, service_name
            ));

            // Generate methods
            for method in &service.method {
                let method_name = method.name.as_deref().unwrap_or("unknown");
                let method_name_snake = to_snake_case(method_name);

                let input_type = method.input_type.as_deref().unwrap_or("");
                let output_type = method.output_type.as_deref().unwrap_or("");

                // Just use the type name without package prefix since we're in the same module
                let input_type_rust = input_type.split('.').next_back().unwrap_or(input_type);
                let output_type_rust = output_type.split('.').next_back().unwrap_or(output_type);

                mod_code.push_str(&format!(
                    "{}    async fn {}(&self, request: {}) -> Result<{}, connect_axum::ConnectError>;\n",
                    indent, method_name_snake, input_type_rust, output_type_rust
                ));
            }

            mod_code.push_str(&format!("{}}}\n\n", indent));

            // Generate metadata for the macro
            mod_code.push_str(&format!(
                "{}/// Metadata for the {} service\n",
                indent, service_name
            ));
            mod_code.push_str(&format!(
                "{}pub mod __{}_meta {{\n",
                indent,
                to_snake_case(service_name)
            ));
            mod_code.push_str(&format!(
                "{}    pub const SERVICE_NAME: &str = \"{}.{}\";\n",
                indent, package, service_name
            ));
            mod_code.push_str(&format!("{}    \n", indent));
            mod_code.push_str(&format!("{}    pub struct MethodMeta {{\n", indent));
            mod_code.push_str(&format!("{}        pub name: &'static str,\n", indent));
            mod_code.push_str(&format!("{}        pub path: &'static str,\n", indent));
            mod_code.push_str(&format!("{}    }}\n", indent));
            mod_code.push_str(&format!("{}    \n", indent));

            // Generate method metadata
            for method in &service.method {
                let method_name = method.name.as_deref().unwrap_or("unknown");
                let method_name_upper = method_name.to_uppercase();
                let full_path = format!("/{}.{}/{}", package, service_name, method_name);

                mod_code.push_str(&format!(
                    "{}    pub const {}: MethodMeta = MethodMeta {{\n",
                    indent, method_name_upper
                ));
                mod_code.push_str(&format!("{}        name: \"{}\",\n", indent, method_name));
                mod_code.push_str(&format!("{}        path: \"{}\",\n", indent, full_path));
                mod_code.push_str(&format!("{}    }};\n", indent));
            }

            mod_code.push_str(&format!("{}}}\n", indent));
        }

        // Close nested modules
        for i in (0..package_parts.len()).rev() {
            let indent = "    ".repeat(i);
            mod_code.push_str(&format!("{}}}\n", indent));
        }
    }

    // Create the response with mod.rs
    // protoc will place this relative to the --connect-rust_out directory
    let response = CodeGeneratorResponse {
        error: None,
        supported_features: Some(1),
        file: vec![File {
            name: Some("generated/mod.rs".to_string()),
            content: Some(mod_code),
            insertion_point: None,
            generated_code_info: None,
        }],
    };

    let mut output = Vec::new();
    response
        .encode(&mut output)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))?;

    io::stdout().write_all(&output)?;

    Ok(())
}

/// Convert PascalCase to snake_case
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    let chars = s.chars().peekable();

    for c in chars {
        if c.is_uppercase() {
            if !result.is_empty() {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }

    result
}
