use heck::ToSnakeCase;
use prost::Message;
use prost_types::{
    FileDescriptorProto, ServiceDescriptorProto,
    compiler::{CodeGeneratorRequest, CodeGeneratorResponse, code_generator_response::File},
};
use quote::{format_ident, quote};
use std::io::{self, Read, Write};

const PKG: &str = env!("CARGO_PKG_NAME");
const VERSION: &str = env!("CARGO_PKG_VERSION");
const NO_SIDE_EFFECTS: i32 = 1; // https://protobuf.dev/reference/cpp/api-docs/google.protobuf.descriptor.pb/

fn main() -> io::Result<()> {
    let mut input = Vec::new();
    io::stdin().lock().read_to_end(&mut input)?;

    let request = CodeGeneratorRequest::decode(&input[..])
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))?;

    let mut output_files = Vec::new();

    for file in &request.proto_file {
        // Only generate for files we're supposed to process
        let file_name = file.name.as_deref().unwrap_or("");
        if !request.file_to_generate.contains(&file_name.to_string()) {
            continue;
        }

        let package = file.package.as_deref().unwrap_or("");
        let prost_file = format!("{}.rs", package);
        let content = generate_file_content(file, package);

        let generated = quote! {
            include!(#prost_file);

            #content
        };

        let syntax_tree: syn::File = syn::parse2(generated)
            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))?;
        let mut formatted = prettyplease::unparse(&syntax_tree);

        formatted = format!(
            "// @generated\n// This file is @generated by {PKG} {VERSION}\n{}",
            formatted
        );

        let filename = format!("{}.connect.rs", package);

        output_files.push(File {
            name: Some(filename),
            content: Some(formatted),
            insertion_point: None,
            generated_code_info: None,
        });
    }

    let response = CodeGeneratorResponse {
        error: None,
        supported_features: Some(1),
        file: output_files,
    };

    let mut output = Vec::new();
    response
        .encode(&mut output)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))?;

    io::stdout().write_all(&output)?;

    Ok(())
}

fn generate_file_content(file: &FileDescriptorProto, package: &str) -> proc_macro2::TokenStream {
    let services: Vec<_> = file
        .service
        .iter()
        .map(|service| generate_service(service, package))
        .collect();

    quote! {
        #(#services)*
    }
}

fn generate_service(service: &ServiceDescriptorProto, package: &str) -> proc_macro2::TokenStream {
    let service_name = service.name.as_deref().unwrap_or("UnknownService");
    let service_ident = format_ident!("{}", service_name);
    let client_ident = format_ident!("{}Client", service_name);
    let meta_mod_name = format_ident!("__{}_meta", service_name.to_snake_case());
    let service_path = format!("{}.{}", package, service_name);

    // MAYBE: make this more programmatic
    let service_trait_methods: Vec<_> = service
        .method
        .iter()
        .map(|method| {
            let method_name = method.name.as_deref().unwrap_or("unknown");
            let method_ident = format_ident!("{}", method_name.to_snake_case());

            let input_type = method.input_type.as_deref().unwrap_or("");
            let output_type = method.output_type.as_deref().unwrap_or("");

            let input_type_rust = input_type.split('.').next_back().unwrap_or(input_type);
            let output_type_rust = output_type.split('.').next_back().unwrap_or(output_type);

            let input_ident = format_ident!("{}", input_type_rust);
            let output_ident = format_ident!("{}", output_type_rust);

            quote! {
                fn #method_ident(
                    &self,
                    request: #input_ident
                ) -> impl std::future::Future<Output = Result<#output_ident, connect_axum::ConnectError>> + Send;
            }
        })
        .collect();

    let client_methods: Vec<_> = service
        .method
        .iter()
        .map(|method| {
            let method_name = method.name.as_deref().unwrap_or("unknown");
            let method_ident = format_ident!("{}", method_name.to_snake_case());
            let method_const = format_ident!("{}", method_name.to_uppercase());

            let input_type = method.input_type.as_deref().unwrap_or("");
            let output_type = method.output_type.as_deref().unwrap_or("");

            let input_type_rust = input_type.split('.').next_back().unwrap_or(input_type);
            let output_type_rust = output_type.split('.').next_back().unwrap_or(output_type);

            let input_ident = format_ident!("{}", input_type_rust);
            let output_ident = format_ident!("{}", output_type_rust);

            quote! {
                pub async fn #method_ident(
                    &self,
                    request: #input_ident
                ) -> Result<#output_ident, connect_axum::ConnectError> {
                    use prost::Message;

                    let mut body = Vec::new();
                    request.encode(&mut body)
                        .map_err(|e| connect_axum::ConnectError::internal(e.to_string()))?;

                    let response = self.client
                        .post(format!("{}{}", self.base_url, #meta_mod_name::#method_const.path))
                        .header("Content-Type", "application/proto")
                        .body(body)
                        .send()
                        .await
                        .map_err(|e| connect_axum::ConnectError::internal(e.to_string()))?;

                    if !response.status().is_success() {
                        return Err(connect_axum::ConnectError::internal(
                            format!("HTTP error: {}", response.status())
                        ));
                    }

                    let response_bytes = response.bytes().await
                        .map_err(|e| connect_axum::ConnectError::internal(e.to_string()))?;

                    let response = #output_ident::decode(&response_bytes[..])
                        .map_err(|e| connect_axum::ConnectError::internal(e.to_string()))?;

                    Ok(response)
                }
            }
        })
        .collect();

    let method_metas: Vec<_> = service
        .method
        .iter()
        .map(|method| {
            let method_name = method.name.as_deref().unwrap_or("unknown"); // MAYBE: error if unknown
            let method_const = format_ident!("{}", method_name.to_uppercase());
            let full_path = format!("/{}/{}", service_path, method_name);

            let is_idempotent = method
                .options
                .as_ref()
                .and_then(|opts| opts.idempotency_level)
                .map(|level| level == NO_SIDE_EFFECTS)
                .unwrap_or(false);

            quote! {
                pub const #method_const: MethodMeta = MethodMeta {
                    name: #method_name,
                    path: #full_path,
                    idempotent: #is_idempotent,
                };
            }
        })
        .collect();

    quote! {
        #[allow(unused)]
        #[doc = concat!("Generated service trait for ", #service_name)]
        pub trait #service_ident: Send + Sync + 'static {
            #(#service_trait_methods)*
        }

        #[allow(unused)]
        #[doc = concat!("Client for ", #service_name)]
        pub struct #client_ident {
            client: reqwest::Client,
            base_url: String,
        }

        #[allow(unused)]
        impl #client_ident {
            pub fn new(base_url: impl Into<String>) -> Self {
                Self {
                    client: reqwest::Client::new(),
                    base_url: base_url.into(),
                }
            }

            pub fn with_client(base_url: impl Into<String>, client: reqwest::Client) -> Self {
                Self {
                    client,
                    base_url: base_url.into(),
                }
            }

            #(#client_methods)*
        }

        #[allow(unused)]
        #[doc = concat!("Metadata for the ", #service_name, " service")]
        pub mod #meta_mod_name {
            pub const SERVICE_NAME: &str = #service_path;

            pub struct MethodMeta {
                pub name: &'static str,
                pub path: &'static str,
                pub idempotent: bool,
            }

            #(#method_metas)*
        }
    }
}
